# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
Utilities to generate toymodel (fake) reconstruction inputs for testing
purposes.

Examples:

.. code-block:: python

    >>> from instrument import CameraGeometry
    >>> geom = CameraGeometry.make_rectangular(20, 20)
    >>> showermodel = Gaussian(x=0.25 * u.m, y=0.0 * u.m,
    length=0.1 * u.m, width=0.02 * u.m, psi='40d')
    >>> image, signal, noise = showermodel.generate_image(geom, intensity=1000)
    >>> print(image.shape)
    (400,)


"""
import numpy as np
from ctapipe.utils import linalg
import astropy.units as u
from astropy.coordinates import Angle
from scipy.stats import multivariate_normal, skewnorm, norm
from abc import ABCMeta, abstractmethod

__all__ = [
    'Gaussian',
    'SkewedGaussian',
    'ImageModel',
]


<<<<<<< HEAD
def generate_2d_shower_model(centroid, width, length, psi):
    """Create a statistical model (2D gaussian) for a shower image in a
    camera. The model's PDF (`model.pdf`) can be passed to
    `make_toymodel_shower_image`.

    Parameters
    ----------
    centroid : (float,float)
        position of the centroid of the shower in camera coordinates
    width : float
        width of shower (minor axis)
    length : float
        length of shower (major axis)
    psi : convertable to `astropy.coordinates.Angle`
        rotation angle about the centroid (0=x-axis)

    Returns
    -------

    a `scipy.stats` object

    """
    aligned_covariance = np.array([[length, 0], [0, width]])
    # rotate by psi angle: C' = R C R+
    rotation = linalg.rotation_matrix_2d(psi)
    rotated_covariance = rotation.dot(aligned_covariance).dot(rotation.T)
    return multivariate_normal(mean=centroid, cov=rotated_covariance)


def make_toymodel_shower_image(geom, showerpdf, intensity=50, nsb_level_pe=50):
    """Generates a pedestal-subtracted shower image from a statistical
    shower model (as generated by `shower_model`). The resulting image
    will be in the same format as the given
    `~ctapipe.image.camera.CameraGeometry`.

    Parameters
    ----------
    geom : `ctapipe.instrument.CameraGeometry`
        camera geometry object 
    showerpdf : func
        PDF function for the shower to generate in the camera, e.g. from a 
    intensity : int
        factor to multiply the model by to get photo-electrons
    nsb_level_pe : type
        level of NSB/pedestal in photo-electrons

    Returns
    -------

    an array of image intensities corresponding to the given `CameraGeometry`

    """
    pos = np.empty(geom.pix_x.shape + (2,))
    pos[..., 0] = geom.pix_x.value
    pos[..., 1] = geom.pix_y.value
    

    model_counts = (showerpdf(pos) * intensity).astype(np.int32)
    signal = np.random.poisson(model_counts)
    noise = np.random.poisson(nsb_level_pe, size=signal.shape)
    image = (signal + noise) - np.mean(noise)

    return image, signal, noise


def gaussian(x, mean, sigma):
    return np.exp(-(x - mean)**2. / (2. * sigma * sigma))


def generate_muon_model(xy, radius, width, centre_x, centre_y):
    r_pix = np.sqrt((xy[..., 0] - centre_x)**2. + (xy[..., 1] - centre_y)**2.)
    Im_pix = gaussian(r_pix, radius, width)
    return Im_pix

def make_toymodel_shower_image_muons(geom, my_par, intensity=50, nsb_level_pe=50):
    """Generates a pedestal-subtracted shower image from a statistical
    shower model (as generated by `shower_model`). The resulting image
    will be in the same format as the given
    `~ctapipe.image.camera.CameraGeometry`.

    Parameters
    ----------
    geom : `ctapipe.instrument.CameraGeometry`
        camera geometry object 
    my_par : parameters of the muon ring
        radius, width, centre_x, centre_y
    intensity : int
        factor to multiply the model by to get photo-electrons
    nsb_level_pe : type
        level of NSB/pedestal in photo-electrons

    Returns
    -------

    an array of image intensities corresponding to the given `CameraGeometry`

    """
    pos = np.empty(geom.pix_x.shape + (2,))
    pos[..., 0] = geom.pix_x.value
    pos[..., 1] = geom.pix_y.value
    

    model_counts = (5*generate_muon_model(pos, my_par[0], my_par[1], my_par[2], my_par[3]) * intensity).astype(np.int32)
    signal = np.random.poisson(model_counts)
    noise = np.random.poisson(nsb_level_pe, size=signal.shape)
    image = (signal + noise) - np.mean(noise)

    return image, signal, noise

def phi_func(xy,r_pix,centre_y):
    n = xy.shape[0]
    phi = np.empty(n)
    for i in range(n):
        if xy[i,1] > centre_y:
            phi[i] = np.arccos((xy[i,1]-centre_y)/r_pix[i])
        else: 
            phi[i] = np.arccos(-1*(xy[i,1]-centre_y)/r_pix[i]) + np.pi
    return phi

def generate_muon_model2(xy,radius,wchange,wmean,centre_x,centre_y):
    """
    wchange is the maximal gaussian width variation along the ring
    wmean is the mean value of the gaussian width 
    """
    r_pix = np.sqrt((xy[..., 0] - centre_x)**2. + (xy[..., 1] - centre_y)**2.)
    phi = phi_func(xy,r_pix,centre_y)
    width = wchange*np.sin(phi - np.pi/2)+wmean
    Im_pix = gaussian(r_pix, radius, width)
    return Im_pix

def make_toymodel_shower_image_muons2(geom, param, intensity=50, nsb_level_pe=50):
    """Generates a pedestal-subtracted shower image from a statistical
    shower model (as generated by `shower_model`). The resulting image
    will be in the same format as the given
    `~ctapipe.image.camera.CameraGeometry`.

    Parameters
    ----------
    geom : `ctapipe.instrument.CameraGeometry`
        camera geometry object 
    param : parameters of the muon ring
        radius, wchange, wmean, centre_x, centre_y
    intensity : int
        factor to multiply the model by to get photo-electrons
    nsb_level_pe : type
        level of NSB/pedestal in photo-electrons

    Returns
    -------

    an array of image intensities corresponding to the given `CameraGeometry`

    """
    pos = np.empty(geom.pix_x.shape + (2,))
    pos[..., 0] = geom.pix_x.value
    pos[..., 1] = geom.pix_y.value
    
    radius, wchange, wmean, centre_x, centre_y = param
    model_counts = (4*generate_muon_model2(pos,radius, wchange, wmean, centre_x, centre_y) * intensity).astype(np.int32)
    signal = np.random.poisson(model_counts)
    noise = np.random.poisson(nsb_level_pe, size=signal.shape)
    image = (signal + noise) - np.mean(noise)

    return image, signal, noise
=======
class ImageModel(metaclass=ABCMeta):

    @u.quantity_input(x=u.m, y=u.m)
    @abstractmethod
    def pdf(self, x, y):
        '''
        Probability density function
        '''
        pass

    def generate_image(self, camera, intensity=50, nsb_level_pe=20):
        """
        Generate a randomized DL1 shower image.
        For the signal, poisson random numbers are drawn from
        the expected signal distribution for each pixel.
        For the background, for each pixel a poisson random number
        if drawn with mean `nsb_level_pe`.

        Parameters
        ----------
        camera : `ctapipe.instrument.CameraGeometry`
            camera geometry object
        intensity : int
            Total number of photo electrons to generate
        nsb_level_pe : type
            level of NSB/pedestal in photo-electrons

        Returns
        -------
        image: array with length n_pixels containing the image
        signal: only the signal part of image
        noise: only the noise part of image
        """
        expected_signal = self.expected_signal(camera, intensity)

        signal = np.random.poisson(expected_signal)
        noise = np.random.poisson(nsb_level_pe, size=signal.shape)
        image = (signal + noise) - np.mean(noise)

        return image, signal, noise

    def expected_signal(self, camera, intensity):
        '''
        Expected signal in each pixel for the given camera
        and total intensity.

        Parameters
        ----------
        camera: `ctapipe.instrument.CameraGeometry`
            camera geometry object
        intensity: int
            Total number of expected photo electrons

        Returns
        -------
        image: array with length n_pixels containing the image
        '''
        pdf = self.pdf(camera.pix_x, camera.pix_y)
        return pdf * intensity * camera.pix_area.value


class Gaussian(ImageModel):
    @u.quantity_input(x=u.m, y=u.m, length=u.m, width=u.m)
    def __init__(self, x, y, length, width, psi):
        """Create 2D Gaussian model for a shower image in a camera.

        Parameters
        ----------
        centroid : u.Quantity[length, shape=(2, )]
            position of the centroid of the shower in camera coordinates
        width: u.Quantity[length]
            width of shower (minor axis)
        length: u.Quantity[length]
            length of shower (major axis)
        psi : convertable to `astropy.coordinates.Angle`
            rotation angle about the centroid (0=x-axis)

        Returns
        -------

        a `scipy.stats` object

        """
        self.x = x
        self.y = y
        self.width = width
        self.length = length
        self.psi = psi

    @u.quantity_input(x=u.m, y=u.m)
    def pdf(self, x, y):
        '''2d probability for photon electrons in the camera plane'''
        aligned_covariance = np.array([
            [self.length.to_value(u.m)**2, 0],
            [0, self.width.to_value(u.m)**2]
        ])
        # rotate by psi angle: C' = R C R+
        rotation = linalg.rotation_matrix_2d(self.psi)
        rotated_covariance = rotation @ aligned_covariance @ rotation.T

        return multivariate_normal(
            mean=[self.x.to_value(u.m), self.y.to_value(u.m)],
            cov=rotated_covariance,
        ).pdf(np.column_stack([x.to_value(u.m), y.to_value(u.m)]))


class SkewedGaussian(ImageModel):
    '''
    A shower image that has a skewness along the major axis
    '''
    @u.quantity_input(x=u.m, y=u.m, length=u.m, width=u.m)
    def __init__(self, x, y, length, width, psi, skewness):
        """Create 2D skewed Gaussian model for a shower image in a camera.
        Skewness is only applied along the main shower axis.
        See https://en.wikipedia.org/wiki/Skew_normal_distribution and
        https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skewnorm.html
        for details

        Parameters
        ----------
        centroid : u.Quantity[length, shape=(2, )]
            position of the centroid of the shower in camera coordinates
        width: u.Quantity[length]
            width of shower (minor axis)
        length: u.Quantity[length]
            length of shower (major axis)
        psi : convertable to `astropy.coordinates.Angle`
            rotation angle about the centroid (0=x-axis)

        Returns
        -------

        a `scipy.stats` object

        """
        self.x = x
        self.y = y
        self.width = width
        self.length = length
        self.psi = psi
        self.skewness = skewness

    def _moments_to_parameters(self):
        '''returns loc and scale from mean, std and skewnewss'''
        # see https://en.wikipedia.org/wiki/Skew_normal_distribution#Estimation
        skew23 = np.abs(self.skewness)**(2 / 3)
        delta = np.sign(self.skewness) * np.sqrt(
            (np.pi / 2 * skew23)
            / (skew23 + (0.5 * (4 - np.pi))**(2 / 3))
        )
        a = delta / np.sqrt(1 - delta**2)
        scale = self.length.to_value(u.m) / np.sqrt(1 - 2 * delta**2 / np.pi)
        loc = - scale * delta * np.sqrt(2 / np.pi)

        return a, loc, scale

    @u.quantity_input(x=u.m, y=u.m)
    def pdf(self, x, y):
        '''2d probability for photon electrons in the camera plane'''
        mu = u.Quantity([self.x, self.y]).to_value(u.m)

        rotation = linalg.rotation_matrix_2d(-Angle(self.psi))
        pos = np.column_stack([x.to_value(u.m), y.to_value(u.m)])
        long, trans = rotation @ (pos - mu).T

        trans_pdf = norm(loc=0, scale=self.width).pdf(trans)

        a, loc, scale = self._moments_to_parameters()

        return trans_pdf * skewnorm(a=a, loc=loc, scale=scale).pdf(long)


class RingGaussian(ImageModel):
    '''
    A shower image consisting of a ring with gaussian radial profile.
    Simplified model for a muon ring.
    '''
    @u.quantity_input(x=u.m, y=u.m, radius=u.m, sigma=u.m)
    def __init__(self, x, y, radius, sigma):
        self.x = x
        self.y = y
        self.sigma = sigma
        self.radius = radius

    @u.quantity_input(x=u.m, y=u.m)
    def pdf(self, x, y):
        '''2d probability for photon electrons in the camera plane'''

        r = np.sqrt((x - self.x)**2 + (y - self.y)**2)

        return norm(
            self.radius.to_value(u.m),
            self.sigma.to_value(u.m),
        ).pdf(r)
>>>>>>> ff85c2f0405285be4a64ab73b83672707961de08
